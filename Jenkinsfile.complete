pipeline {
    agent any
    
    environment {
        APP_NAME = 'automarkly-frontend'
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        AWS_REGION = 'ap-south-1'
        TEST_EMAIL = 'sara.beck.dev@gmail.com'
        
        // S3 and CloudFront - from Jenkins Credentials
        S3_BUCKET = credentials('s3-static-bucket')
        CLOUDFRONT_DISTRIBUTION_ID = credentials('cloudfront-distribution-id')
        CLOUDFRONT_DOMAIN = credentials('cloudfront-domain')
        
        // For E2E Tests - ECR images
        AWS_ACCOUNT_ID = credentials('aws-account-id')
        ECR_PROD_BACKEND = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/automarkly/emailservice-backend"
        ECR_PROD_WORKER = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/automarkly/emailservice-worker"
        
        GITOPS_REPO = credentials('gitops-repo-url')
        HELM_VALUES_PATH = 'charts/email-service/values.yaml'
        PRODUCTION_URL = credentials('production-url')
    }

    triggers {
        githubPush()
    }
    
    stages {
        stage('Checkout') {
            when {
                anyOf {
                    branch 'main'
                    branch 'feature/*'
                    branch 'release/*'
                }
            }
            steps {
                checkout scm
                sshagent(['github']) {
                    sh "git fetch --tags --unshallow || git fetch --tags"
                }
            }
        }
        
        stage('Unit Tests') {
            when {
                anyOf {
                    branch 'main'
                    branch 'feature/*'
                    branch 'release/*'
                }
            }
            steps {
                sh '''
                    docker build -f Dockerfile.test -t "${APP_NAME}:test-${BUILD_NUMBER}" .
                    mkdir -p test-results
                    docker run --rm \\
                        -v "${PWD}/test-results:/app/test-results" \\
                        "${APP_NAME}:test-${BUILD_NUMBER}"
                '''
            }
            post {
                always {
                    archiveArtifacts artifacts: 'test-results/**/*', allowEmptyArchive: true
                    sh 'docker rmi "${APP_NAME}:test-${BUILD_NUMBER}" || true'
                }
            }
        }
        
        stage('Build Static Files') {
            when {
                anyOf {
                    branch 'main'
                    branch 'feature/*'
                    branch 'release/*'
                }
            }
            steps {
                sh '''
                    # Build using production Dockerfile
                    docker build --target artifacts -t "${APP_NAME}:artifacts-${BUILD_NUMBER}" .
                    CONTAINER_ID=$(docker create "${APP_NAME}:artifacts-${BUILD_NUMBER}")
                    rm -rf build
                    docker cp "${CONTAINER_ID}:/build" ./build
                    docker rm "${CONTAINER_ID}"
                    
                    # Verify build output
                    if [ ! -d "build/static" ]; then
                        echo "❌ Build verification failed"
                        exit 1
                    fi
                '''
            }
            post {
                always {
                    sh 'docker rmi "${APP_NAME}:artifacts-${BUILD_NUMBER}" || true'
                }
            }
        }
        
        stage('Upload to S3 - Staging') {
            when {
                allOf {
                    anyOf {
                        branch 'main'
                        branch 'feature/*'
                        branch 'release/*'
                    }
                    expression { fileExists('build/static') }
                }
            }
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    sh '''
                        # Upload static assets with long cache
                        aws s3 sync build/static/ s3://${S3_BUCKET}/staging/${BUILD_NUMBER}/static/ \\
                            --cache-control "max-age=31536000,public,immutable" \\
                            --delete
                        
                        # Upload HTML and service worker with no cache
                        aws s3 sync build/ s3://${S3_BUCKET}/staging/${BUILD_NUMBER}/ \\
                            --cache-control "max-age=0,no-cache,no-store,must-revalidate" \\
                            --exclude "static/*" \\
                            --delete
                        
                        echo "✅ Staging files uploaded to: s3://${S3_BUCKET}/staging/${BUILD_NUMBER}/"
                    '''
                }
            }
        }
        
        stage('Run E2E Tests') {
            when {
                anyOf {
                    branch 'main'
                    branch 'feature/*'
                    branch 'release/*'
                }
            }
            steps {
                build job: 'e2e-email-service',
                      parameters: [
                          string(name: 'BACKEND_IMAGE', value: "${ECR_PROD_BACKEND}:latest"),
                          string(name: 'FRONTEND_IMAGE', value: "STATIC_FILES"),
                          string(name: 'WORKER_IMAGE', value: "${ECR_PROD_WORKER}:latest"),
                          string(name: 'STATIC_FILES_URL', value: "https://${CLOUDFRONT_DOMAIN}/staging/${BUILD_NUMBER}"),
                          string(name: 'TEST_EMAIL', value: "${TEST_EMAIL}")
                      ],
                      wait: true
            }
        }
        
        stage('Create Version Tag') {
            when { 
                anyOf {
                    branch 'main'
                    branch 'release/*'
                }
            }
            steps {
                script {
                    sh '''
                        curl -L https://github.com/GitTools/GitVersion/releases/download/6.4.0/gitversion-linux-x64-6.4.0.tar.gz -o gitversion.tar.gz
                        tar -xzf gitversion.tar.gz
                        chmod +x gitversion
                        ./gitversion -showvariable SemVer > version.txt
                    '''
                    env.MAIN_TAG = readFile('version.txt').trim()
                    sh 'rm -f gitversion* version.txt'
                }
            }
        }
        
        stage('Deploy to Production S3') {
            when { 
                anyOf {
                    branch 'main'
                    branch 'release/*'
                }
            }
            steps {
                retry(3) {
                    sh '''
                        echo "🚀 Deploying to production S3..."
                        
                        # Upload static assets with long cache
                        aws s3 sync build/static/ s3://${S3_BUCKET}/static/ \\
                            --cache-control "max-age=31536000,public,immutable" \\
                            --delete
                        
                        # Upload HTML and service worker with no cache
                        aws s3 sync build/ s3://${S3_BUCKET}/ \\
                            --cache-control "max-age=0,no-cache,no-store,must-revalidate" \\
                            --exclude "static/*" \\
                            --delete
                        
                        echo "✅ Production files uploaded to: s3://${S3_BUCKET}/"
                    '''
                }
            }
        }
        
        stage('CloudFront Invalidation') {
            when { 
                anyOf {
                    branch 'main'
                    branch 'release/*'
                }
            }
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    sh '''
                        echo "🔄 Creating CloudFront invalidation..."
                        
                        INVALIDATION_ID=$(aws cloudfront create-invalidation \\
                            --distribution-id ${CLOUDFRONT_DISTRIBUTION_ID} \\
                            --paths "/*" \\
                            --query 'Invalidation.Id' \\
                            --output text)
                        
                        echo "Invalidation ID: $INVALIDATION_ID"
                        
                        # Wait for invalidation to complete
                        aws cloudfront wait invalidation-completed \\
                            --distribution-id ${CLOUDFRONT_DISTRIBUTION_ID} \\
                            --id $INVALIDATION_ID
                        
                        echo "✅ CloudFront invalidation completed!"
                    '''
                }
            }
        }
        
        stage('Deploy via GitOps') {
            when { 
                anyOf {
                    branch 'main'
                    branch 'release/*'
                }
            }
            steps {
                sshagent(['github']) {
                    sh '''
                        rm -rf gitops-config
                        git clone "${GITOPS_REPO}" gitops-config
                    '''
                    
                    withCredentials([
                        string(credentialsId: 'git-username', variable: 'GIT_USERNAME'),
                        string(credentialsId: 'git-email', variable: 'GIT_EMAIL')
                    ]) {
                        dir('gitops-config') {
                            sh '''
                                git config user.email "${GIT_EMAIL}"
                                git config user.name "${GIT_USERNAME}"

                                sed -i '/staticFiles:/,/version:/ s/version: ".*"/version: "'${MAIN_TAG}'"/' "${HELM_VALUES_PATH}"
                                
                                if git diff --quiet "${HELM_VALUES_PATH}"; then
                                    echo "No changes to deploy"
                                else
                                    git add "${HELM_VALUES_PATH}"
                                    git commit -m "Deploy frontend static files v${MAIN_TAG} - Build ${BUILD_NUMBER}"
                                    git push origin main
                                fi
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Production Smoke Tests') {
            when { 
                anyOf {
                    branch 'main'
                    branch 'release/*'
                }
            }
            steps {
                timeout(time: 3, unit: 'MINUTES') {
                    sh '''
                        echo "🧪 Running production smoke tests..."
                        
                        # Test CloudFront distribution
                        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${CLOUDFRONT_DOMAIN}/")
                        if [ "$HTTP_STATUS" != "200" ]; then
                            echo "❌ CloudFront health check failed: $HTTP_STATUS"
                            exit 1
                        fi
                        
                        # Test production URL if available
                        curl -f "${PRODUCTION_URL}/" || echo "Production URL not available yet"
                        
                        echo "✅ Production smoke tests passed!"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            script {
                def status = currentBuild.result ?: 'SUCCESS'
                def emoji = status == 'SUCCESS' ? '✅' : '❌'
                
                emailext(
                    to: "${TEST_EMAIL}",
                    subject: "${emoji} ${APP_NAME} Build #${BUILD_NUMBER} - ${status}",
                    body: """
                        Pipeline: ${status}
                        Build: #${BUILD_NUMBER}
                        Duration: ${currentBuild.durationString}
                        
                        ${status == 'SUCCESS' ? 
                            "🌐 Live at: https://${CLOUDFRONT_DOMAIN}/" : 
                            "❌ Build failed - check logs"}
                        
                        📊 Details: ${BUILD_URL}
                    """
                )
            }
            
            sh '''
                # Cleanup
                rm -rf build gitops-config || true
                docker system prune -f || true
            '''
            cleanWs()
        }
        success {
            echo '✅ Frontend S3 deployment completed successfully!'
        }
        failure {
            echo '❌ Frontend S3 deployment failed!'
        }
    }
}